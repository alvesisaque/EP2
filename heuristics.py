from state import State
import sys

def applicable(state, actions):
    ''' Return a list of applicable actions in a given `state`. '''
    app = list()
    for act in actions:
        if State(state).intersect(act.precond) == act.precond:
            app.append(act)
    return app

# def sum(dic, preconds):
#     sum = 0

#     for cond in preconds:
#         val = dic.get(cond)
#         if (val == None):
#             return Integer.MAX_VALUE
#         sum += val

#     return sum

def successorRelaxed(state, action):
    ''' Return the sucessor state generated by executing `action` in `state`. '''
    return State(action.pos_effect).union(state)

def h_naive(state=None, planning=None, goal=None):
    return 0

def h_add(state, planning, goal):
    '''
    Return heuristic h_add value for `state`.

    OBSERVATION: It receives `planning` object in order
    to access the applicable actions and problem information.
    '''
    state_prepositions = dict() 
    actions = planning.actions
    aux_state = state
    for preposition in aux_state:
        state_prepositions[preposition] = 0
    change = True
    while change:
        change = False
        actionsApplicable = applicable(aux_state, actions)
        for action in actionsApplicable:
            aux_state = successorRelaxed(aux_state, action)
            for effect in action.pos_effect:
                prev = state_prepositions.get(effect,sys.maxsize)
                state_prepositions[effect] = min(prev,(1+sum(state_prepositions.get(pre, sys.maxsize) for pre in action.precond)))
                if prev != state_prepositions[effect]:
                    change = True
    return sum(state_prepositions.get(i,sys.maxsize) for i in goal)


def h_max(state, planning, goal=None):
    '''
    Return heuristic h_max value for `state`.

    OBSERVATION: It receives `planning` object in order
    to access the applicable actions and problem information.
    '''
    state_prepositions = dict() 
    actions = planning.actions
    aux_state = state
    for preposition in aux_state:
        state_prepositions[preposition] = 0
    change = True
    while change:
        change = False
        actionsApplicable = applicable(aux_state, actions)
        for action in actionsApplicable:
            aux_state = successorRelaxed(aux_state, action)
            for effect in action.pos_effect:
                prev = state_prepositions.get(effect,sys.maxsize)
                state_prepositions[effect] = min(prev,(1+sum(state_prepositions.get(pre, sys.maxsize) for pre in action.precond)))
                if prev != state_prepositions[effect]:
                    change = True
    h_max = 0  
    for key in state_prepositions:
        h_max = max(h_max, state_prepositions.get(key))
    return h_max


def h_ff(state, planning, goal):
    '''
    Return heuristic h_ff value for `state`.

    OBSERVATION: It receives `planning` object in order
    to access the applicable actions and problem information.
    '''
    graphplan = dict()
    actions = planning.actions
    aux_state = state
    isGoal = False
    if aux_state.intersect(goal) == goal:
        return 0
    level = 0
    graphplan[(level,'state')] = aux_state
    while not isGoal:
        actionsApplicable = applicable(aux_state,actions)
        level += 1
        for a in actionsApplicable:
            aux_state = successorRelaxed(aux_state,a)
            if aux_state.intersect(goal) == goal:
                isGoal = True
                break
            graphplan[(level,'state')] = aux_state
            graphplan[(level,'action')] = actionsApplicable
    thisLevelGoals = set()
    thisLevelGoals = thisLevelGoals.union(goal)
    relaxedActions = set()
    while (level > 0):
        prevLevelGoals = set()
        for tg in thisLevelGoals:
            if tg in graphplan[level-1,'state']:
                prevLevelGoals.add(tg)
            else:
                for a in graphplan[level,'action']:
                    if tg in a.pos_effect:
                        prevLevelGoals = prevLevelGoals.union(a.precond)
                        relaxedActions.add(a)
                        break 
        level -= 1
        thisLevelGoals = prevLevelGoals.copy()
    return len(relaxedActions)
