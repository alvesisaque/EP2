from state import State

def applicable(state, actions):
    ''' Return a list of applicable actions in a given `state`. '''
    app = list()
    for act in actions:
        if State(state).intersect(act.precond) == act.precond:
            app.append(act)
    return app

def soma(dic, preconds):
    soma = 0

    for cond in preconds:
        val = dic.get(cond)
        if (val == None):
            return Integer.MAX_VALUE
        soma += val

    return soma

def successorRelaxed(state, action):
    ''' Return the sucessor state generated by executing `action` in `state`. '''
    return State(action.pos_effect).union(state)

def h_naive(state=None, planning=None, goal=None):
    return 0

def h_add(state, planning, goal=None):
    '''
    Return heuristic h_add value for `state`.

    OBSERVATION: It receives `planning` object in order
    to access the applicable actions and problem information.
    '''
    state_prepositions = {}
    for preposition in state:
        state_prepositions[preposition] = 0

    x = state
    for action in applicable(state, planning.actions):
        x.union(action.pos_effect)

        for effect in action.pos_effect:
            old_state_prepositions = state_prepositions

            sm = 0
            val = state_prepositions.get(effect)
            if (val == None):
                sm = 1 + soma(state_prepositions, action.precond)
            else:
                sm = min(1 + soma(state_prepositions, action.precond), val)
            state_prepositions[effect] = sm 

            if (old_state_prepositions != state_prepositions):
                break

        
    custo = 0    
    for key in state_prepositions:
        custo += state_prepositions.get(key)

    return custo


def h_max(state, planning, goal=None):
    '''
    Return heuristic h_max value for `state`.

    OBSERVATION: It receives `planning` object in order
    to access the applicable actions and problem information.
    '''
    state_prepositions = {}
    for preposition in state:
        state_prepositions[preposition] = 0

    x = state
    for action in applicable(state, planning.actions):
        x.union(action.pos_effect)

        for effect in action.pos_effect:
            old_state_prepositions = state_prepositions

            sm = 0
            val = state_prepositions.get(effect)
            if (val == None):
                sm = 1 + soma(state_prepositions, action.precond)
            else:
                sm = min(1 + soma(state_prepositions, action.precond), val)
            state_prepositions[effect] = sm 
        
            if (old_state_prepositions != state_prepositions):
                break

    maximo = 0  
    for key in state_prepositions:
        maximo = max(maximo, state_prepositions.get(key))

    return maximo


def h_ff(state, planning, goal):
    '''
    Return heuristic h_ff value for `state`.

    OBSERVATION: It receives `planning` object in order
    to access the applicable actions and problem information.
    '''
    graphplan = dict() #graphplan relaxed
    actions = planning.actions
    X = state
    isGoal = False
    if X.intersect(goal) == goal: #ja estamos na meta entao o comprimento (a quantidade) de acoes necessaria eh zero
        return 0
    level = 0
    graphplan[(level,'state')] = X
    #PHASE 1 - expand graph
    while not isGoal:
        actionsApplicable = applicable(X,actions)
        level += 1
        for a in actionsApplicable:
            X = successorRelaxed(X,a) #added positive effects of a
            if X.intersect(goal) == goal:
                isGoal = True
                break
            graphplan[(level,'state')] = X
            graphplan[(level,'action')] = actionsApplicable
    #PHASE 2 - busca regressiva - partindo dos atomos do goal ate termos os atomos do state
    thisLevelGoals = set()
    thisLevelGoals = thisLevelGoals.union(goal)
    relaxedActions = set()
    while (level > 0):
        prevLevelGoals = set()
        for tg in thisLevelGoals:
            if tg in graphplan[level-1,'state']:
                prevLevelGoals.add(tg)
            else:
                for a in graphplan[level,'action']:
                    if tg in a.pos_effect:
                        prevLevelGoals = prevLevelGoals.union(a.precond)
                        relaxedActions.add(a)
                        break 
        level -= 1
        thisLevelGoals = prevLevelGoals.copy()
    return len(relaxedActions)
